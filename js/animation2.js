// Generated by CoffeeScript 1.8.0
var animate, attributes, camera, createvertex, geometry, init, mouseX, mouseY, onDocumentMouseMove, onWindowResize, particleMaterial, particles, raycaster, render, renderer, scene, shaderMaterial, uniforms, update, x, _i;

scene = new THREE.Scene();

scene.fog = new THREE.FogExp2(0x000000, 0.005);

camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 3000);

camera.position.z = 200;

renderer = new THREE.WebGLRenderer({
  antialias: true
});

raycaster = new THREE.Raycaster();

geometry = new THREE.Geometry();

createvertex = function() {
  var R, alpha, beta, vertex;
  vertex = new THREE.Vector3();
  alpha = 2 * Math.random() * Math.PI - Math.PI;
  beta = 2 * Math.random() * Math.PI - Math.PI;
  R = 100;
  vertex.x = R * Math.sin(alpha) * Math.cos(beta);
  vertex.y = R * Math.sin(alpha) * Math.sin(beta);
  vertex.z = R * Math.cos(alpha);
  geometry.vertices.push(vertex);
};

for (x = _i = 0; _i <= 300; x = ++_i) {
  createvertex();
}

attributes = {
  size: {
    type: 'f',
    value: []
  },
  customColor: {
    type: 'c',
    value: []
  }
};

uniforms = {
  color: {
    type: 'c',
    value: new THREE.Color(0x006869)
  },
  texture: {
    type: 't',
    value: THREE.ImageUtils.loadTexture("img/point.png")
  }
};

pointTexture = THREE.ImageUtils.loadTexture("img/point2.png");

shaderMaterial = new THREE.ShaderMaterial({
  uniforms: uniforms,
  attributes: attributes
});

particleMaterial = new THREE.PointCloudMaterial({
  size: 5,
  color:0xffffff,
  map: pointTexture,
  blending: THREE.AdditiveBlending,
  transparent: true
});

particles = new THREE.PointCloud(geometry, particleMaterial);

mouseX = 0;

mouseY = 0;

init = function() {
  var line, lineMaterial;
  renderer.setSize(window.innerWidth, window.innerHeight);
  $("body").append(renderer.domElement);
  scene.add(particles);
  lineMaterial = new THREE.LineBasicMaterial({
    color: 0x006869,
    apacity: 0.4,
    linewidth: 1
  });
  line = new THREE.Line(geometry.clone(), lineMaterial);
  scene.add(line);
  document.addEventListener('mousemove', onDocumentMouseMove, false);
  window.addEventListener('resize', onWindowResize, false);
};

onWindowResize = function(event) {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
};

onDocumentMouseMove = function(event) {
  mouseX = event.clientX - window.innerWidth / 2;
  mouseY = event.clientY - window.innerHeight / 2;
};

animate = function() {
  requestAnimationFrame(animate);
  render();
  update();
};

render = function() {
  renderer.render(scene, camera);
};

update = function() {
  var intersects, preX, preY, vector;
  preX = camera.position.x + (mouseX - camera.position.x) * 0.008;
  if (-100 < preX && preX < 100) {
    camera.position.x = preX;
  }
  preY = camera.position.y + (mouseY - camera.position.y) * 0.008;
  if (-50 < preY && preY < 50) {
    camera.position.y = preY;
  }
  vector = new THREE.Vector3(mouseX, mouseY, 1).unproject(camera);
  raycaster.ray.set(camera.position, vector.sub(camera.position).normalize());
  intersects = raycaster.intersectObject(particles);
  camera.lookAt(scene.position);
};

init();

animate();
