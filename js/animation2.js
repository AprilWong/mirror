// Generated by CoffeeScript 1.8.0
(function() {
  var INTERSECTED, PARTICLE_SIZE, animate, attributes, camera, createvertex, geometry, init, mouse, onDocumentMouseClick, onDocumentMouseMove, onWindowResize, particleMaterial, particles, pointpng, raycaster, render, renderer, scene, shaderMaterial, uniforms, update, v, values_color, values_size, vertices, vl, x, _i, _j;

  scene = new THREE.Scene();

  scene.fog = new THREE.FogExp2(0x000000, 0.005);

  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 3000);

  camera.position.z = 200;

  renderer = new THREE.WebGLRenderer({
    antialias: true
  });

  raycaster = new THREE.Raycaster();

  geometry = new THREE.Geometry();

  mouse = {
    x: 1,
    y: 1
  };

  PARTICLE_SIZE = 3;

  INTERSECTED = null;

  createvertex = function() {
    var R, alpha, beta, vertex;
    vertex = new THREE.Vector3();
    alpha = 2 * Math.random() * Math.PI - Math.PI;
    beta = 2 * Math.random() * Math.PI - Math.PI;
    R = 100;
    vertex.x = R * Math.sin(alpha) * Math.cos(beta);
    vertex.y = R * Math.sin(alpha) * Math.sin(beta);
    vertex.z = R * Math.cos(alpha);
    geometry.vertices.push(vertex);
  };

  for (x = _i = 0; _i <= 300; x = ++_i) {
    createvertex();
  }

  pointpng = THREE.ImageUtils.loadTexture("img/point2.png");

  attributes = {
    size: {
      type: 'f',
      value: []
    },
    customColor: {
      type: 'c',
      value: []
    }
  };

  uniforms = {
    color: {
      type: 'c',
      value: new THREE.Color(0x006869)
    },
    texture: {
      type: 't',
      value: pointpng
    }
  };

  shaderMaterial = new THREE.ShaderMaterial({
    uniforms: uniforms,
    attributes: attributes,
    vertexShader: document.getElementById('vertexshader').textContent,
    fragmentShader: document.getElementById('fragmentshader').textContent,
    alphaTest: 0.9
  });

  particleMaterial = new THREE.PointCloudMaterial({
    size: 5,
    color: 0xffffff,
    map: pointpng,
    blending: THREE.AdditiveBlending,
    transparent: true
  });

  particles = new THREE.PointCloud(geometry, shaderMaterial);

  values_size = attributes.size.value;

  values_color = attributes.customColor.value;

  vertices = particles.geometry.vertices;

  vl = vertices.length;

  for (v = _j = 0; 0 <= vl ? _j <= vl : _j >= vl; v = 0 <= vl ? ++_j : --_j) {
    values_size[v] = PARTICLE_SIZE;
    values_color[v] = new THREE.Color().setHSL(0.4 + 0.12 * (v / vl), 8, 0.5);
  }

  init = function() {
    var line, lineMaterial;
    renderer.setSize(window.innerWidth, window.innerHeight);
    $("body").append(renderer.domElement);
    scene.add(particles);
    lineMaterial = new THREE.LineBasicMaterial({
      color: 0x006869,
      apacity: 0.4,
      linewidth: 1
    });
    line = new THREE.Line(geometry.clone(), lineMaterial);
    scene.add(line);
    document.addEventListener('mousemove', onDocumentMouseMove, false);
    document.addEventListener('mousedown', onDocumentMouseClick, false);
    window.addEventListener('resize', onWindowResize, false);
  };

  onWindowResize = function(event) {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  };

  onDocumentMouseMove = function(event) {
    event.preventDefault();
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  };

  onDocumentMouseClick = function(event) {
    event.preventDefault();
    console.log("INTERSECTED:" + INTERSECTED);
  };

  animate = function() {
    requestAnimationFrame(animate);
    render();
    update();
  };

  render = function() {
    renderer.render(scene, camera);
  };

  update = function() {
    var intersects, preX, preY, vector;
    preX = camera.position.x + mouse.x * 3;
    if (-100 < preX && preX < 100) {
      camera.position.x = preX;
    }
    preY = camera.position.y + mouse.y * 3;
    if (-50 < preY && preY < 50) {
      camera.position.y = preY;
    }
    vector = new THREE.Vector3(mouse.x, mouse.y, 1).unproject(camera);
    raycaster.ray.set(camera.position, vector.sub(camera.position).normalize());
    intersects = raycaster.intersectObject(particles);
    if (intersects.length > 0) {
      if (INTERSECTED !== intersects[0].index) {
        attributes.size.value[INTERSECTED] = PARTICLE_SIZE;
        INTERSECTED = intersects[0].index;
        attributes.size.value[INTERSECTED] = PARTICLE_SIZE * 3;
        attributes.size.needsUpdate = true;
      }
    }
    camera.lookAt(scene.position);
  };

  init();

  animate();

}).call(this);
